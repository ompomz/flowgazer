<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>flowgazer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; padding: 0.5rem; line-height: 1.3; font-weight: normal; background-color: #f7f7f7; color: #666; font-size: 0.9rem; }
.container { max-width: 600px; margin-left: 0.5rem; margin-right: auto; padding: 0.5rem 0.5rem 0rem 0.5rem; }
@media (max-width: 767px) { .container { max-width: 100%; padding: 8px 8px 0px 8px; margin: 0; } }
@media (max-width: 400px) { .flex-container button {font-size: 0.6rem !important;} }
h1 { font-size: 1.2rem; margin: 0rem 0rem 0.5rem 0rem; }
p { margin: 0; }
a { color: #666; text-decoration: none; }
input, textarea { font-size: 0.9rem; padding: 0.5rem 1rem; border: 1px solid #ddd; border-radius: 4px; color: #666; background-color: #fff; cursor: pointer; transition: background-color 0.3s, color 0.3s; }
.container button { font-size: 0.8rem; font-weight: bold; padding: 0.25rem 1rem; margin: 0.5rem 0rem; border: 0px solid #ddd; border-radius: 999px; color: #fff; background-color: #666; white-space: nowrap; cursor: pointer; transition: background-color 0.3s, color 0.3s; }
.full-width { width: 100%; display: block; }
.hidden { display: none; }
.flex-container { display: flex; align-items: center; gap: 0.5rem; margin:0.5rem 0rem;}
.flex-container input, .flex-container textarea { flex-grow: 1; margin: 0; }
.flex-container button { margin: 0; min-width: 0; }
.flex-container-matome { display: flex; flex-direction: column; align-items: flex-start; gap:0.25rem;}
#settings-toggle-area { display: flex; justify-content: center; }
textarea { font-family: monospace; resize: vertical; }
ul { list-style-type: none; padding: 0; margin: 0.55rem 0rem 0rem 0rem; }
li.event { word-break: break-all; padding: 0.5rem; border-top: 1px dashed #ddd; }
.event-highlighted { border: 2px solid #ffcc66; }
.npub-link { color: #66b3ff; white-space: normal; word-break: break-word; min-width: 0; flex: 1; }
.nostr-ref, .pubkey-ref { color: #66b3ff; }
.custom-emoji { height: 1.1rem; vertical-align: bottom; }
#load-more { font-size: 0.8rem; font-weight: bold; padding: 0.25rem 1rem; margin: 0.5rem 0rem; border: 0px solid #ddd; border-radius: 999px; color: #fff; background-color: #666; white-space: nowrap; cursor: pointer; transition: background-color 0.3s, color 0.3s; }
#load-more.loading { font-size: 0; pointer-events: none;}
#load-more.loading::before { content: "読み込み中..."; font-size: initial;}
#generate-keypair { background-color: #ff99cc; color: #ffffff; }
#generate-keypair:hover { background-color: #ff66b2; }
#get-from-extension, #load-more { background-color: #66b3ff; color: #ffffff; }
#get-from-extension:hover, #load-more:hover { background-color: #4da6ff; }
#send-new-post { background-color: #ffcc66; color: #ffffff; }
#send-new-post:hover { background-color: #ffb833; }
#subscribe-relay, #apply-filter, #clear-filter { background-color: #ffd700; color: #ffffff;}
#subscribe-relay:hover, #apply-filter:hover, #clear-filter:hover { background-color: #ffc400;}
#show-settings, #hide-settings { background-color: #999999; color: #ffffff; font-size:0.7rem; font-weight:normal; padding:0.2rem 1rem; margin:0; }
#show-settings:hover, #hide-settings:hover { background-color: #888888; }
</style>
<script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>
</head>
<body>
<div id="header-placeholder"></div>
<div class="container">
<a href="https://github.com/ompomz/ompomz.github.io/tree/main/flowgazer"><h1>flowgazer</h1></a>
<p>このページでは、鍵を作って・投稿して・タイムラインを見ることができるよ。作ったのはGemini。</p>
<div class="flex-container">
<button id="generate-keypair" style="flex-grow:1;">新しい鍵ペアを生成して試す</button>
<button id="get-from-extension" style="flex-grow:1;">ブラウザ拡張機能からログイン</button>
</div>
<span style="display:block; margin: 0.5rem 0rem;">秘密鍵（nsec）:</span>
<input id="nsec" type="text" placeholder="nsec1..." class="full-width" style="margin-bottom:0.5rem;">
<p id="warning-message" class="hidden" style="margin-top:-0.5rem;margin-bottom:0.5rem;">⚠️秘密鍵を紛失すると、そのアカウントは二度と使えません。大事にしてね。</p>
<div style="display: flex;"><span style="white-space: nowrap;">公開鍵（npub）:</span><a id="npub-link" class="npub-link" target="_blank" rel="noreferrer"></a></div>
<textarea id="new-post-content" rows="3" placeholder="いまなにしてる？" class="full-width" style="margin-top:0.5rem;"></textarea>
<button id="send-new-post" class="full-width">投稿</button>
<div id="settings-toggle-area">
<button id="show-settings">詳細設定を表示</button>
<button id="hide-settings" class="hidden">詳細設定を隠す</button>
</div>
<div id="advanced-settings" class="hidden">
<label for="relay-url">リレーURL</label>
<div class="flex-container">
<input list="relay-suggestions" id="relay-url" type="text">
<datalist id="relay-suggestions">
<option value="wss://r.kojira.io/">
<option value="wss://yabu.me/">
<option value="wss://relay-jp.nostr.wirednet.jp/">
<option value="wss://relay.damus.io">
<option value="wss://nos.lol">
<option value="wss://relay.nostr.band">
</datalist>
<button id="subscribe-relay">接続</button>
</div>
<label for="client-filter-toggle"><input type="checkbox" id="client-filter-toggle" checked>flowgazerで絞り込む</label>
<label for="hex-filter">投稿者pubkeyしぼりこみ（hex, npub, nprofile）</label>
<p>複数の鍵は、カンマ、改行、スペースで区切れます</p>
<div class="flex-container">
<textarea id="hex-filter" rows="3" placeholder="hex, npub1..., ..."></textarea>
<div class="flex-container-matome">
<button id="apply-filter">適用</button>
<button id="clear-filter" style="padding:0.25rem 0.6rem;">クリア</button>
</div></div>
</div>
</div>
<ul id="timeline"></ul>
<button type="button" id="load-more" class="loading full-width">もっと見る</button>
<div id="status-area">
<span id="checking-datetime"></span><button id="cancel-loading" style="display: none;">あきらめる</button>
</div>
<script>
  String.prototype.padStart = String.prototype.padStart ? String.prototype.padStart : function(targetLength, padString) {
    targetLength = Math.floor(targetLength) || 0;
    if (targetLength < this.length) return String(this);
    padString = padString ? String(padString) : " ";
    var pad = "";
    var len = targetLength - this.length;
    var i = 0;
    while (pad.length < len) {
      if (!padString[i]) {
        i = 0;
      }
      pad += padString[i];
      i++;
    }
    return pad + String(this).slice(0);
  };

  function getLanguage() {
    return (window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage).substring(0, 2);
  }

  function generateKeypair() {
    const seckey = window.NostrTools.generateSecretKey();
    const pubkey = window.NostrTools.getPublicKey(seckey);
    return {
      seckeyHex: seckey,
      pubkeyHex: pubkey,
      nsec: window.NostrTools.nip19.nsecEncode(seckey),
      npub: window.NostrTools.nip19.npubEncode(pubkey)
    };
  }

  const getFromExtensionButton = document.getElementById('get-from-extension');
  const nsecInput = document.getElementById('nsec');
  const npubLink = document.getElementById('npub-link');
  const warningMessageArea = document.getElementById('warning-message');
  
  getFromExtensionButton.addEventListener('click', async() => {
    if (!window.nostr) {
      alert('NIP-07対応のブラウザ拡張機能が見つかりません。');
      return;
    }
    try {
      const pubkeyHex = await window.nostr.getPublicKey();
      const npub = window.NostrTools.nip19.npubEncode(pubkeyHex);

      nsecInput.value = '********';
      nsecInput.readOnly = true;
      nsecInput.placeholder = 'ブラウザ拡張機能でログイン中';

      npubLink.textContent = npub;
      npubLink.href = 'https://nostter.app/' + npub;
      npubLink.style.display = 'inline';

      warningMessageArea.classList.add('hidden');

      window.nostrSigner = window.nostr;

      alert('ブラウザ拡張機能から公開鍵を取得しました！これで投稿できます。');
    } catch (error) {
      console.error('NIP-07拡張機能からの公開鍵取得に失敗しました:', error);
      alert('公開鍵の取得に失敗しました。拡張機能が有効になっているか、パーミッションが許可されているか確認してください。');
      nsecInput.readOnly = false;
      nsecInput.placeholder = 'nsec1...';
      npubLink.textContent = '';
      npubLink.href = '';
      npubLink.style.display = 'none';
      warningMessageArea.classList.remove('hidden');
    }
  });


  var postContentInput = document.getElementById("new-post-content");
  var sendPostButton = document.getElementById("send-new-post");

  async function sendeNewPost() {
    var nsec = nsecInput.value;
    var content = postContentInput.value;
    if (!content) {
      alert("投稿内容を入力してください。");
      return;
    }

    if (nsec === '********' && window.nostrSigner) {
      try {
        const pubkeyHex = await window.nostrSigner.getPublicKey();
        const post = {
          kind: 1,
          content: content,
          created_at: Math.floor(Date.now() / 1000),
          tags: [
            ["client", "flowgazer", "31990:a19caaa8404721584746fb0e174cf971a94e0f51baaf4c4e8c6e54fa88985eaf:1755917022711", "wss://relay.nostr.band"]
          ],
          pubkey: pubkeyHex,
        };
        const signedPost = await window.nostrSigner.signEvent(post);
        relayWS.send(JSON.stringify(["EVENT", signedPost]));
        postContentInput.value = "";
        alert('投稿に成功しました！');
      } catch (err) {
        console.error(err);
        alert("投稿に失敗しました。拡張機能が有効になっているか確認してください。");
      }

    } else {
      if (!nsec) {
        alert("秘密鍵を入力してください。");
        return;
      }
      try {
        var nsecDecoded = window.NostrTools.nip19.decode(nsec);
        if (nsecDecoded.type !== "nsec") {
          alert("無効な秘密鍵です。");
          return;
        }
        var seckey = nsecDecoded.data;
        var post = {
          kind: 1,
          content: content,
          created_at: Math.floor(Date.now() / 1000),
          tags: [
            ["client", "flowgazer", "31990:a19caaa8404721584746fb0e174cf971a94e0f51baaf4c4e8c6e54fa88985eaf:1755917022711", "wss://relay.nostr.band"]
          ],
        };
        var signedPost = window.NostrTools.finalizeEvent(post, seckey);
        relayWS.send(JSON.stringify(["EVENT", signedPost]));
        postContentInput.value = "";
        alert('投稿に成功しました！');
      } catch (err) {
        console.error(err);
        alert("投稿に失敗しました。");
      }
    }
  }

  sendPostButton.addEventListener("click", sendeNewPost);


  window.addEventListener('DOMContentLoaded', () => {
    document.getElementById('hide-settings').classList.add('hidden');
    document.getElementById('advanced-settings').classList.add('hidden');
    document.getElementById('npub-link').style.display = 'none';

    const savedFilter = localStorage.getItem('hexFilterValue');
    if (savedFilter) {
      document.getElementById('hex-filter').value = savedFilter;
    }

    const links = document.querySelectorAll('a');

    links.forEach(link => {
      if (!link.target || link.target === '_self') {
        link.setAttribute('target', '_blank');
      }
      if (!link.rel) {
        link.setAttribute('rel', 'noopener noreferrer');
      }
    });
  });

  function formatTimestamp(date) {
    return String(date.getHours()).padStart(2, "0") + ":" + String(date.getMinutes()).padStart(2, "0") + ":" + String(date.getSeconds()).padStart(2, "0");
  }

  function findTagWithValue(tags, name, value, extraPred) {
    for (var i = 0; i < tags.length; i++) {
      var tag = tags[i];
      if (tag[0] === name && tag[1] === value && (extraPred ? extraPred(tag) : true)) {
        return tag;
      }
    }
    return undefined;
  }

  function baseEventView() {
    var li = document.createElement("li");
    li.classList.add("event");
    return li;
  }

  function externalLink(url, text) {
    var a = document.createElement("a");
    a.href = url;
    a.target = "_blank";
    a.rel = "noreferrer";
    a.textContent = text;
    return a;
  }

  function timestampView(unixtime, eventId) {
    var ts = new Date(unixtime * 1000);
    var timeElem = document.createElement("a");
    const currentRelay = relayUrlInput.value;
    const neventEncoded = window.NostrTools.nip19.neventEncode({
      id: eventId,
      relays: [currentRelay]
    });
    timeElem.href = "https://njump.me/" + neventEncoded;
    timeElem.setAttribute("datetime", ts.toISOString());
    timeElem.textContent = "[" + formatTimestamp(ts) + "]";
    timeElem.target = "_blank";
    timeElem.rel = "noreferrer";
    return timeElem;
  }

  function pubkeyView(pubkey) {
    var npub = window.NostrTools.nip19.npubEncode(pubkey);
    var displayName = profiles[pubkey] && profiles[pubkey].name ? profiles[pubkey].name : pubkey.substring(0, 8);
    var sanitizedName = displayName.replace(/\p{Emoji_Presentation}/gu, "");
    if (sanitizedName.length === 0) {
      sanitizedName = pubkey.substring(0, 8);
    } else if (sanitizedName.length > 8) {
      sanitizedName = sanitizedName.substring(0, 8);
    }
    var a = externalLink("https://njump.me/" + npub, sanitizedName);
    a.classList.add("pubkey-ref");

    return a;
  }

  function metadataView(nostrEv) {
    var view = document.createElement("span");
    view.appendChild(timestampView(nostrEv.created_at, nostrEv.id));
    view.appendChild(document.createTextNode(" "));
    view.appendChild(pubkeyView(nostrEv.pubkey));
    view.appendChild(document.createTextNode(" > "));
    return view;
  }

  var contentRefPattern = /(https?:\/\/[^\s]+)|(nostr:[\w]+1[ac-hj-np-z02-9]+)|(:[_a-zA-Z0-9]+:)/;

  function indexOfFirstUnmatchingCloseParen(url) {
    var nest = 0;
    for (var i = 0; i < url.length; i++) {
      var c = url.charAt(i);
      if (c === "(") {
        nest++;
      } else if (c === ")") {
        if (nest <= 0) {
          return i;
        }
        nest--;
      }
    }
    return -1;
  }

  function urlLinkElems(url) {
    var splitIdx = indexOfFirstUnmatchingCloseParen(url);
    var finalUrl = splitIdx === -1 ? url : url.substring(0, splitIdx);
    var rest = splitIdx === -1 ? "" : url.substring(splitIdx);

    var link = externalLink(finalUrl, finalUrl);

    if (rest.length === 0) {
      return [link];
    }
    var restSpan = document.createElement("span");
    restSpan.textContent = rest;
    return [link, restSpan];
  }

  function extractEventRef(nip19Decoded) {
    switch (nip19Decoded.type) {
      case "nevent":
        return {
          id: nip19Decoded.data.id,
          author: nip19Decoded.data.author
        };
      case "note":
        return {
          id: nip19Decoded.data
        }
      default:
        return undefined;
    }
  }

  function extractReplyRef(tags) {
    var root;

    for (var i = 0; i < tags.length; i++) {
      var tag = tags[i];
      if (tag[0] !== "e") {
        continue;
      }
      if (tag[3] === "reply" && typeof tag[1] === "string") {
        return {
          id: tag[1],
          author: typeof tag[4] === "string" ? tag[4] : undefined
        };
      }
      if (root === undefined && tag[3] === "root" && typeof tag[1] === "string") {
        root = {
          id: tag[1],
          author: typeof tag[4] === "string" ? tag[4] : undefined
        };
      }
    }
    return root;
  }

  function nostrRefLink(nip19Id, idType) {
    var abbrId = nip19Id.substring(0, idType.length + 8) + "...";
    var a = externalLink("https://njump.me/" + nip19Id, "nostr:" + abbrId);
    a.classList.add("nostr-ref");
    return a;
  }

  function nostrEventRefLink(nip19id, idType, hexEventId) {
    var abbrId = nip19id.substring(0, idType.length + 8) + "...";
    var a = document.createElement("a");
    a.textContent = "nostr:" + abbrId;
    a.classList.add("nostr-ref");

    if (document.getElementById(hexEventId)) {
      a.href = "#" + hexEventId;
    } else {
      a.href = "https://njump.me/" + nip19id;
      a.target = "_blank";
      a.rel = "noreferrer";
    }
    return a;
  }

  var lastHighlightedEventId;
  window.addEventListener("hashchange", function() {
    if (window.location.hash.length === 0) {
      return;
    }
    var hash = window.location.hash.substring(1);
    if (hash.length === 0) {
      return;
    }
    if (lastHighlightedEventId) {
      var highlighted = document.getElementById(lastHighlightedEventId);
      if (highlighted) {
        highlighted.classList.remove("event-highlighted");
      }
    }
    var target = document.getElementById(hash);
    if (!target) {
      return;
    }
    lastHighlightedEventId = hash;
    target.classList.add("event-highlighted");
  });

  function pubkeyMention(pubkey) {
    var pubkeyRef = pubkeyView(pubkey);
    pubkeyRef.classList.add("pubkey-mention");
    return pubkeyRef;
  }

  function referentAuthor(pubkey) {
    var span = document.createElement("span");
    span.appendChild(document.createTextNode(" by "));
    span.appendChild(pubkeyView(pubkey));
    return span;
  }

  function inReplyToElems(nostrEv) {
    var replyRef = extractReplyRef(nostrEv.tags);
    if (replyRef === undefined) {
      return [];
    }

    var replySuffix = document.createElement("span");
    replySuffix.textContent = "<< ";
    replySuffix.classList.add("reply-suffix");

    var nevent = window.NostrTools.nip19.neventEncode(replyRef);
    var replyLink = nostrEventRefLink(nevent, "nevent", replyRef.id);

    if (!replyRef.author) {
      return [replyLink, replySuffix];
    }
    return [replyLink, referentAuthor(replyRef.author), replySuffix];
  }

  function postQuotationElems(nip19Id, idType, hexEventId, author) {
    var prefix = document.createElement("span");
    prefix.textContent = "QP: ";
    prefix.classList.add("quote-prefix");

    var link = nostrEventRefLink(nip19Id, idType, hexEventId);

    if (!author) {
      return [prefix, link];
    }
    return [prefix, link, referentAuthor(author)];
  }

  function nostrUriElems(ref, nostrEv) {
    var nip19Id = ref.substring(6);
    var dec;
    try {
      dec = window.NostrTools.nip19.decode(nip19Id);
    } catch (err) {
      console.error("failed to decode NIP-19 ID:", err);
      return [document.createTextNode(ref)];
    }

    switch (dec.type) {
      case "npub":
        return [pubkeyMention(dec.data)];
      case "nprofile":
        return [pubkeyMention(dec.data.pubkey)];

      case "note":
      case "nevent":
        var evRef = extractEventRef(dec);
        if (ref === undefined) {
          console.error("unreachable");
          return [nostrRefLink(nip19Id, dec.type)];
        }
        var mentionTag = findTagWithValue(nostrEv.tags, "e", evRef.id, function(t) {
          t[3] === "mention"
        });
        var author = (mentionTag && mentionTag[4]) || evRef.author;
        return postQuotationElems(nip19Id, dec.type, evRef.id, evRef.author);

      default:
        return [nostrRefLink(nip19Id, dec.type)];
    }
  }

  function customEmojiElems(shortcode, nostrEv) {
    var emojiName = shortcode.substring(1, shortcode.length - 1);
    for (var i = 0; i < nostrEv.tags.length; i++) {
      var tag = nostrEv.tags[i];
      if (tag[0] === "emoji" && tag[1] === emojiName && typeof tag[2] === "string") {
        var img = document.createElement('img');
        img.src = tag[2];
        img.alt = shortcode;
        img.classList.add("custom-emoji");
        return [img];
      }
    }
    return [document.createTextNode(shortcode)];
  }

  function postEventView(nostrEv) {
    var view = baseEventView();
    view.id = nostrEv.id;
    view.classList.add("event-post");

    view.appendChild(metadataView(nostrEv));

    inReplyToElems(nostrEv).forEach(function(e) {
      view.appendChild(e);
    });

    var contentElems = nostrEv.content.split(contentRefPattern)
      .filter(function(s) {
        return s !== undefined && s.length > 0;
      })
      .map(function(s) {
        if (s.indexOf("http") === 0) {
          return urlLinkElems(s);
        } else if (s.indexOf("nostr:") === 0) {
          return nostrUriElems(s, nostrEv);
        } else if (s.charAt(0) === ":" && s.charAt(s.length - 1) === ":") {
          return customEmojiElems(s, nostrEv);
        } else {
          return [document.createTextNode(s)];
        }
      });
    contentElems.forEach(function(elems) {
      elems.forEach(function(e) {
        view.appendChild(e);
      });
    });

    return view;
  }

  function repostEventView(nostrEv) {
    var targetPostId;
    var targetPostAuthor;
    for (var i = 0; i < nostrEv.tags.length; i++) {
      var tag = nostrEv.tags[i];
      if (tag[0] === "e" && typeof tag[1] === "string") {
        targetPostId = tag[1];
      }
      if (tag[0] === "p" && typeof tag[1] === "string") {
        targetPostAuthor = tag[1];
      }
      if (targetPostId && targetPostAuthor) {
        break;
      }
    }
    if (targetPostId === undefined) {
      console.error("repost without target post ID:", nostrEv);
      return undefined;
    }

    var view = baseEventView();
    view.classList.add("event-repost");

    view.appendChild(metadataView(nostrEv));

    var repostPrefix = document.createElement("span");
    repostPrefix.textContent = "RP: ";
    repostPrefix.classList.add("repost-prefix");

    var nevent = window.NostrTools.nip19.neventEncode({
      id: targetPostId
    });
    var repostLink = nostrEventRefLink(nevent, "nevent", targetPostId);

    view.appendChild(repostPrefix);
    view.appendChild(repostLink);
    if (targetPostAuthor) {
      view.appendChild(referentAuthor(targetPostAuthor));
    }
    return view;
  }

  var supportedKinds = [1];
  var profiles = {};
  var events = {};
  var filteredAuthors = null;
  const FIXED_CLIENT_TAG = "31990:a19caaa8404721584746fb0e174cf971a94e0f51baaf4c4e8c6e54fa88985eaf:1755917022711";
  var newEventsCount = 0;

  function onEvent(nostrEv, prepend) {
    if (!window.NostrTools.verifyEvent(nostrEv)) {
      console.error("nostr event with invalid signature:", nostrEv);
      return;
    }
    if (nostrEv.kind === 0) {
      try {
        profiles[nostrEv.pubkey] = JSON.parse(nostrEv.content);
        refreshTimeline();
      } catch (e) {
        console.error("Failed to parse profile content:", e);
      }
      return;
    }
    if (supportedKinds.indexOf(nostrEv.kind) === -1) {
      console.error("unsupported kind:", nostrEv.kind);
      return;
    }

    // 31990クライアントタグでの絞り込みをチェックボックスの状態に基づいて適用
    const toggleChecked = clientFilterToggle.checked;
    if (nostrEv.kind === 1 && toggleChecked) {
      const hasCorrectClientTag = nostrEv.tags.some(tag => 
        tag[0] === 'client' && tag.length > 2 && tag[2] === FIXED_CLIENT_TAG
      );
      if (!hasCorrectClientTag) {
        return;
      }
    }

    if (events[nostrEv.id]) {
      return;
    }
    events[nostrEv.id] = nostrEv;
    oldestCreatedAt = Math.min(oldestCreatedAt, nostrEv.created_at);
    pubkeysToFetch.add(nostrEv.pubkey);
    newEventsCount++;
    var eventView;
    switch (nostrEv.kind) {
      case 1:
        eventView = postEventView(nostrEv);
        break;
      default:
        return;
    }
    if (eventView === undefined) {
      return;
    }
    if (prepend) {
      timeline.insertBefore(eventView, timeline.firstChild);
    } else {
      timeline.appendChild(eventView);
    }
  }

  function refreshTimeline() {
    while (timeline.firstChild) {
      timeline.removeChild(timeline.firstChild);
    }
    var sortedEvents = Object.values(events).sort((a, b) => b.created_at - a.created_at);
    sortedEvents.forEach(e => {
      if (e.kind === 1) {
        timeline.appendChild(postEventView(e));
      }
    });
  }

  var MAIN_SUB_ID = "motherfuncking-main-sub";
  var MORE_POSTS_SUB_ID = "motherfuncking-more-posts";
  var PROFILE_SUB_ID = "motherfuncking-profile-sub";

  var pubkeysToFetch = new Set();
  var currentSubId;

  function isKnownSubId(subId) {
    return subId === MAIN_SUB_ID || subId === MORE_POSTS_SUB_ID || subId === PROFILE_SUB_ID;
  }

  function shouldPrependPost(subId, afterEose) {
    return subId === MAIN_SUB_ID && afterEose;
  }

  var relayWS;
  var isSubscribed = false;

  function subscribeRelay(relayUrl, authors) {
    if (isSubscribed && relayWS) {
      relayWS.close();
    }
    
    while (timeline.firstChild) {
      timeline.removeChild(timeline.firstChild);
    }

    try {
      relayWS = new WebSocket(relayUrl);
    } catch (err) {
      console.error("failed to connect to relay:", err);
      alert("Failed to connect to relay:", relayUrl);
      return;
    }

    events = {};
    pubkeysToFetch = new Set();
    oldestCreatedAt = Number.MAX_VALUE;
    newEventsCount = 0;
    
    // UIのリセット
    loadMoreButton.classList.remove("loading");
    checkingDatetime.textContent = "";
    cancelLoadingButton.style.display = "none";
    
    isSubscribed = true;
    
    var afterEose = false;
    
    // フィルター設定にチェックボックスの状態を反映
    var filter = {
      kinds: [1],
      limit: 50
    };
    if (authors && authors.length > 0) {
      filter.authors = authors;
    }

    // 31990クライアントタグのフィルターを適用
    const toggleChecked = clientFilterToggle.checked;
    if (toggleChecked) {
      filter["#t"] = ["31990"];
    }


    relayWS.addEventListener("open", function() {
      currentSubId = MAIN_SUB_ID;
      relayWS.send(
        JSON.stringify(["REQ", currentSubId, filter])
      );
    });

    relayWS.addEventListener("message", function(ev) {
      try {
        var r2cMsg = JSON.parse(ev.data);
        switch (r2cMsg[0]) {
          case "EVENT":
            var subId = r2cMsg[1];
            if (!isKnownSubId(subId)) {
              console.error("unknown subId:", subId);
              return;
            }
            onEvent(r2cMsg[2], shouldPrependPost(subId, afterEose));
            break;
          case "EOSE":
            var subId = r2cMsg[1];
            if (subId === MAIN_SUB_ID) {
              afterEose = true;
              fetchProfiles();
            }
            if (subId === MORE_POSTS_SUB_ID) {
              loadMoreButton.classList.remove("loading");
              checkingDatetime.textContent = "";
              cancelLoadingButton.style.display = "none";
              if (newEventsCount === 0) {
                console.log("No new posts found, fetching more automatically...");
                loadMoreButton.click();
              } else {
                newEventsCount = 0;
              }
            }
            break;
          default:
            console.log(r2cMsg);
            break;
        }
      } catch (err) {
        console.error(err);
      }
    });
    relayWS.addEventListener("close", function() {
      console.log("Relay connection closed.");
      isSubscribed = false;
      loadMoreButton.classList.remove("loading");
      checkingDatetime.textContent = "";
      cancelLoadingButton.style.display = "none";
    });
  }

  function fetchProfiles() {
    if (pubkeysToFetch.size === 0) {
      return;
    }
    var profileRelayWS = new WebSocket("wss://relay.nostr.band");
    profileRelayWS.addEventListener("open", function() {
      var pubkeysArray = Array.from(pubkeysToFetch);
      profileRelayWS.send(
        JSON.stringify(["REQ", PROFILE_SUB_ID, {
          kinds: [0],
          authors: pubkeysArray
        }])
      );
    });
    profileRelayWS.addEventListener("message", function(ev) {
      try {
        var r2cMsg = JSON.parse(ev.data);
        switch (r2cMsg[0]) {
          case "EVENT":
            var nostrEv = r2cMsg[2];
            if (nostrEv.kind === 0) {
              try {
                var profileContent = JSON.parse(nostrEv.content);
                profiles[nostrEv.pubkey] = profileContent;
                pubkeysToFetch.delete(nostrEv.pubkey);
              } catch (e) {
                console.error("Failed to parse profile content:", e);
              }
            }
            break;
          case "EOSE":
            refreshTimeline();
            profileRelayWS.close();
            break;
        }
      } catch (err) {
        console.error(err);
      }
    });
  }

  var timeline = document.getElementById("timeline");
  if (timeline === null) {
    throw new Error("no #timeline");
  }

  var LS_RELAY_URL_KEY = "relayUrl";
  var relayUrlInput = document.getElementById("relay-url");
  var subscribeButton = document.getElementById("subscribe-relay");
  subscribeButton.addEventListener("click", function() {
    var rurl = relayUrlInput.value;
    subscribeRelay(rurl, filteredAuthors);
    localStorage.setItem(LS_RELAY_URL_KEY, rurl);
  });

  var latestRurl = localStorage.getItem(LS_RELAY_URL_KEY);
  var defaultRurl = getLanguage() === "ja" ? "wss://r.kojira.io" : "wss://nos.lol/";
  var initialRurl = latestRurl || defaultRurl;
  relayUrlInput.value = initialRurl;

  subscribeRelay(initialRurl, filteredAuthors);

  var generateButton = document.getElementById("generate-keypair");
  var keypairArea = document.getElementById("keypair-area");

  generateButton.addEventListener("click", function() {
    const keys = generateKeypair();
    nsecInput.value = keys.nsec;
    nsecInput.readOnly = false;
    nsecInput.placeholder = 'nsec1...';

    npubLink.textContent = keys.npub;
    npubLink.href = "https://nostter.app/" + keys.npub;
    npubLink.style.display = "inline";

    settingsArea.classList.add("hidden");
    hideSettingsBtn.classList.add("hidden");
    showSettingsBtn.classList.remove("hidden");

    warningMessageArea.classList.remove("hidden");
  });

  npubLink.addEventListener("click", function(event) {
    window.open(this.href, "_blank");
  });

  nsecInput.addEventListener("input", function() {
    const nsecValue = nsecInput.value.trim();
    if (nsecValue) {
      try {
        const nsecDecoded = window.NostrTools.nip19.decode(nsecValue);
        if (nsecDecoded.type === 'nsec') {
          const seckey = nsecDecoded.data;
          const pubkey = window.NostrTools.getPublicKey(seckey);
          const npub = window.NostrTools.nip19.npubEncode(pubkey);
          npubLink.textContent = npub;
          npubLink.href = "https://nostter.app/" + npub;
          npubLink.style.display = "inline";
          return;
        }
      } catch (e) {
      }
    }
    npubLink.textContent = '';
    npubLink.href = '';
    npubLink.style.display = 'none';
  });

  var showSettingsBtn = document.getElementById("show-settings");
  var hideSettingsBtn = document.getElementById("hide-settings");
  var settingsArea = document.getElementById("advanced-settings");

  showSettingsBtn.addEventListener("click", function() {
    settingsArea.classList.remove("hidden");
    showSettingsBtn.classList.add("hidden");
    hideSettingsBtn.classList.remove("hidden");
  });

  hideSettingsBtn.addEventListener("click", function() {
    settingsArea.classList.add("hidden");
    hideSettingsBtn.classList.add("hidden");
    showSettingsBtn.classList.remove("hidden");
  });

  var hexFilterInput = document.getElementById("hex-filter");
  var applyFilterButton = document.getElementById("apply-filter");
  var clearFilterButton = document.getElementById("clear-filter");

  function filterAuthors() {
    var inputText = hexFilterInput.value;
    if (!inputText.trim()) {
      return [];
    }
    var authors = inputText.split(/[ ,　\n]/);
    var filtered = authors.map(function(hex) {
      hex = hex.trim();
      if (hex.startsWith('npub') || hex.startsWith('nprofile')) {
        try {
          var decoded = NostrTools.nip19.decode(hex);
          if (decoded.type === 'npub') {
            return decoded.data;
          } else if (decoded.type === 'nprofile') {
            return decoded.data.pubkey;
          }
        } catch (e) {
          return null;
        }
      }
      return hex.length === 64 && /^[0-9a-fA-F]{64}$/.test(hex) ? hex : null;
    }).filter(Boolean);
    return filtered;
  }

  applyFilterButton.addEventListener("click", function() {
    filteredAuthors = filterAuthors();
    var rurl = relayUrlInput.value;
    localStorage.setItem('hexFilterValue', hexFilterInput.value);
    subscribeRelay(rurl, filteredAuthors);
  });

  clearFilterButton.addEventListener("click", function() {
    hexFilterInput.value = "";
    filteredAuthors = null;
    localStorage.removeItem('hexFilterValue');
    var rurl = relayUrlInput.value;
    subscribeRelay(rurl, filteredAuthors);
  });
  
  const clientFilterToggle = document.getElementById("client-filter-toggle");
  if (clientFilterToggle) {
    clientFilterToggle.addEventListener("change", function() {
      const rurl = relayUrlInput.value;
      subscribeRelay(rurl, filteredAuthors);
    });
  }
  
  const checkingDatetime = document.getElementById("checking-datetime");
  const cancelLoadingButton = document.getElementById("cancel-loading");

  var loadMoreButton = document.getElementById("load-more");
  var oldestCreatedAt = Number.MAX_VALUE;

  loadMoreButton.addEventListener("click", function() {
    if (this.classList.contains("loading")) {
      return;
    }
    this.classList.add("loading");
    newEventsCount = 0;
    
    const date = new Date(oldestCreatedAt * 1000);
    const dateString = date.getFullYear() + "/" + (date.getMonth() + 1).toString().padStart(2, "0") + "/" + date.getDate().toString().padStart(2, "0");
    checkingDatetime.textContent = "確認中日時：" + dateString + "のkind:1";
    cancelLoadingButton.style.display = "inline-block";

    var filter = {
      kinds: [1],
      until: oldestCreatedAt - 1,
      limit: 1000
    };
    if (filteredAuthors && filteredAuthors.length > 0) {
      filter.authors = filteredAuthors;
    }

    // 31990クライアントタグのフィルターを適用
    const toggleChecked = clientFilterToggle.checked;
    if (toggleChecked) {
      filter["#t"] = ["31990"];
    }
    
    currentSubId = MORE_POSTS_SUB_ID;
    relayWS.send(JSON.stringify(["REQ", currentSubId, filter]));
  });

  cancelLoadingButton.addEventListener("click", function() {
    if (relayWS && relayWS.readyState === WebSocket.OPEN) {
      relayWS.send(JSON.stringify(["CLOSE", currentSubId]));
    }
    loadMoreButton.classList.remove("loading");
    checkingDatetime.textContent = "";
    cancelLoadingButton.style.display = "none";
  });
</script>
<script src="https://ompomz.github.io/header/loadHeader.js"></script>
</body>
</html>
